# 프로그래머스 - 경주로 건설 (Swift)

DFS 혹은 BFS 를 이용하여 푸는문제

BFS 로 해보려 했으나 실패해서

DFS로 다시풀어서 합격..!

​

1. 방향설정 -> 우 하 좌 상 으로 순서대로 움직인다고 가정한 후 [[0,1][1,0][0,-1][-1,0]] 배열생성

(이 순서대로 안하면 오답이 나옴 DFS에서 처음에 상단이나 왼쪽으로 가면 바로 끝나버려서 그런듯)

​

2. (0,0) 부터 시작한다고 가정한 후 DFS -> 왼쪽으로 , DFS -> 하단으로 시전

​

3. DFS 빠저나오는 조건은 블록이 1이거나 최소비용이 지금 경로의 비용보다 작을경우

​

4. 방향이 같으면 + 100원 / 다르면 100원 + 500원 해서 + 600원

​

후... 말로설명하려니 복잡하네 

홧팅!!

​
```swift
    import Foundation
    var INF = 1000000000
    var N = 0
    func solution(_ board:[[Int]]) -> Int {
        var min_arr:[Int] = []
        N = board.count
        var direction = [[0,1],[1,0],[0,-1],[-1,0]]
        var minCost = Array(repeating : Array(repeating:INF,count:N) ,count : N) // 최소비용 저장 배열


        func check(_ y:Int, _ x:Int,_ cost:Int) -> Bool{
            if (y < N && y >= 0) && (x < N && x >= 0) {
                if (board[y][x] != 1) && (minCost[y][x] > cost) {
                    minCost[y][x] = cost
                    return true    
                }
            }
            return false
        }

        func dfs(_ y:Int, _ x:Int,_ dir:Int,_ cost:Int){

            if !check(y,x,cost){return} // 블록이 배열 범위 밖으로 나가거나 블록값이 1이거나 최소비용만족 못할경우 판별

            for (i,d) in direction.enumerated(){ //4가지 방향대로 DFS를 순차적으로 실행
                let next_y = y + d[0]
                let next_x = x + d[1]
                var c = cost

                if dir != i {c += 600} // 방향이 다르면 600원 추가
                else {c += 100} // 같으면 100원 추가
                dfs(next_y,next_x,i,c)
            }
        }

        dfs(direction[0][0],direction[0][1],0,100) //시작을 왼쪽으로 이동하는 DFS
        min_arr.append(minCost[N - 1][N - 1])

        minCost = Array(repeating : Array(repeating:INF,count:N) ,count : N)

        dfs(direction[1][0],direction[1][1],1,100) // 시작을 오른쪽으로 이동하는 DFS
        min_arr.append(minCost[N - 1][N - 1])

        return min_arr.min()!
    }
```