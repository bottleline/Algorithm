1. 2차원배열 순서대로 노드 번호를 마지막에 삽입

2. y가 큰 순서대로 배열정렬

3. 포문을 돌며 tree 딕셔너리에 nodeNum : [x,y,left,right] 이렇게 초기화 left right 는 -1 로 초기화

4. add함수 작성 - nodeinfo 를 순서대로 돌며 트리에 삽입 -> 자식노드가 -1 일 경우 부모노드보다 크면 오른쪽 작으면 왼쪽 / 자식노드에 뭐가 있을경우 add(자식노드,삽입노드) 로 재귀함수호출

5. 위처럼 모든 트리에 노드를 삽입후 전위순회 후위순회 하여 노드값을 저장

​
문제풀다가 너무 졸려서 자다가 일어나서 푸는데 너무 안풀려서 인터넷 살짝 보고 풀었다..

​

    import Foundation
    var tree:[Int:[Int]] = [:]

    var temp:[Int] = []
    func solution(_ nodeinfo:[[Int]]) -> [[Int]] {
        var nodeinfo = nodeinfo
        var answer:[[Int]] = []
    
        for (i,nf) in nodeinfo.enumerated() {
            nodeinfo[i] = nf + [i + 1]
        }
        nodeinfo.sort(by:{ $0[1]>$1[1]})
        let root = nodeinfo[0][2]
        for node in nodeinfo{
            let x = node[0]
            let y = node[1]
            let idx = node[2]
            tree[idx] = [x,y,-1,-1]
        }

    
        for i in 1..<nodeinfo.count{
            add(root,nodeinfo[i])
        }
        preorder(root)
        answer.append(temp)
        temp = []
        postorder(root)
        answer.append(temp)
        return answer
    }

    func preorder(_ idx:Int){
        let l = 2
        let r = 3
    
        if idx == -1 {return}
    
        temp.append(idx)
    
        preorder(tree[idx]![l])
        preorder(tree[idx]![r])
    }

    func postorder(_ idx:Int){
        let l = 2
        let r = 3
    
        if idx == -1 {return}

        postorder(tree[idx]![l])
        postorder(tree[idx]![r])
        temp.append(idx)
    }

    func add(_ startNodeIndex : Int , _ newNode:[Int] ){
        let x = 0
        let y = 1
        let l = 2
        let r = 3
        let idx = 2
        if tree[startNodeIndex]![x] < newNode[x]{
            if tree[startNodeIndex]![r] == -1{
                tree[startNodeIndex]![r] = newNode[idx]
                tree[newNode[idx]] = [newNode[x],newNode[y],-1,-1]
            }else{
                let child = tree[startNodeIndex]![r]
                add(child, newNode)
            }
        }else if tree[startNodeIndex]![x] > newNode[x]{
            if tree[startNodeIndex]![l] == -1{
                tree[startNodeIndex]![l] = newNode[idx]
                tree[newNode[idx]] = [newNode[x],newNode[y],-1,-1]
            }else{
                let child = tree[startNodeIndex]![l]
                add(child, newNode)
            }
        }
    }