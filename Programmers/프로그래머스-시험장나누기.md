# 프로그래머스 - 시험장 나누기 (Swift)
[그림1]
![1](https://user-images.githubusercontent.com/42457589/132798452-80f6e3af-376b-45fc-a588-161d15f64a04.png)
하나의 노드는 하나의 시험장을 나타냅니다.
검은 바탕의 흰 숫자는 해당 시험장의 고유 번호(ID)를 나타냅니다.

2-1. 시험장이 n개 있다면, 시험장의 고유 번호는 0부터 n-1까지 부여됩니다.

노드 안의 빨간 숫자는, 해당 시험장의 응시자 수를 나타냅니다.

3-1. 위의 그림에서, 9번 시험장에는 10명, 4번 시험장에는 8명, 6번 시험장에는 20명의 응시자가 시험을 볼 예정입니다.

노드 사이의 간선은 해당 시험장이 연결되어 있음을 의미합니다.

4-1. 위의 그림에서, 9번 시험장은 7번 시험장과, 7번 시험장은 6번 시험장과 연결되어 있습니다.

코딩 테스트를 총괄하는 무지는 안정적인 시험을 위해, 시험장에서 오는 트래픽을 k개의 그룹으로 나누어 각 그룹별 서버로 분산시키기로 하였습니다. 시험장 사이를 연결한 간선들 중 k-1개를 끊어서 시험장을 k 개의 그룹으로 나눌 계획입니다. 이때, 그룹별 최대 트래픽을 최소화하기 위하여 가장 큰 그룹의 인원을 최소화시켜야 합니다.

[그림2]
![2](https://user-images.githubusercontent.com/42457589/132798454-ca3ef788-6207-4400-b1f6-187cd336546d.png)

위의 그림에서 7번과 6번 시험장을 잇는 간선을 끊고, 9번과 7번 시험장을 잇는 간선을 끊는다면, 전체 시험장은 3개의 그룹으로 나누어집니다.

주황색 노드로 표시된 A그룹의 인원은 35명(10+8+5+6+1+1+4)
보라색 노드로 표시된 B그룹의 인원은 37명(7+30)
녹색 노드로 표시된 C그룹의 인원은 40명(20+8+12)
즉, 인원이 가장 많은 그룹은 40명입니다. 다른 어떤 방법으로 시험장을 3개의 그룹으로 나눈다고 해도, 인원이 가장 많은 그룹의 인원이 40명 미만이 되도록 나눌 수는 없습니다.

나눌 그룹의 수를 나타내는 정수 k, 각 시험장의 응시자 수를 나타내는 1차원 정수 배열 num, 시험장의 연결 상태를 나타내는 2차원 정수 배열 links가 매개변수로 주어집니다. 인원이 가장 많은 그룹의 인원이 최소화되도록 k개의 그룹으로 나누었을 때, 최소화된 최대 그룹의 인원을 return 하도록 solution 함수를 완성해주세요.

제한사항
1 ≤ k ≤ 10,000
k ≤ num의 길이 ≤ 10,000
num[i]에는 i번 시험장의 응시자 수가 담겨있습니다.
1 ≤ num의 원소 ≤ 10,000
links의 길이 = num의 길이
links의 i번째 행은 i번 노드(시험장)의 [왼쪽 자식 노드 번호, 오른쪽 자식 노드 번호]입니다.
해당 위치에 자식 노드가 없는 경우 -1이 담겨있습니다.
잘못된 노드 번호나, 하나의 이진 트리 구조가 아닌 입력은 주어지지 않습니다.
정확성 테스트 케이스 제한 사항
1 ≤ k ≤ 20
k ≤ num의 길이 ≤ 20
효율성 테스트 케이스 제한 사항
주어진 조건 외 추가 제한사항 없습니다.

# 풀이
간선을 삭제했을때의 모든 조합을 찾아서 풀었지만 효율성에서 실패..
방법은 아래와 같이풀었다.

1. 모든 간선들의 정보를 배열에 저장

2. 모든간선들에서 k-1 개의 조합을 선택

3. 조합들로 for문을 돌며 간선을 삭제하고 삭제된 간선에 달린 자식노드부터 전위순회하여 합을 구한다.

4. 위에서 구한합 중 최대값을 배열에다가 저장, 모든 조합을 돌며 모든 최대값들을 배열에 저장

5. 배열중 최소값을 반환

​
```swift
   import Foundation

    func solution(_ k:Int, _ num:[Int], _ links:[[Int]]) -> Int {

        var lines:[[Int]] = []
        var lineCombs : [[[Int]]] = []
        var links = links
        var sum = 0
        var root = -1
        var max = 0
        var maxArray:[Int] = []
    
    
        func comb(_ arr:[[Int]],_ e:[[Int]], _ index:Int, _ n:Int){
            var empty = e
            if e.count == n{
                lineCombs.append(e)
                return
            }else{
                if index > arr.count - 1 {
                    return
                }
                empty.append(arr[index])
                comb(arr, empty, index + 1, n)
                comb(arr, e ,index + 1, n)
            }
        }
    
        func findRoot(_ tree:[[Int]]) {
            for i in 0..<tree.count{
                preorder(i,tree)
                if sum == num.reduce(0,+){
                    root = i
                    break;
                }
                sum = 0
            }
            sum = 0
        }
    
    
    
        func preorder(_ start:Int,_ tree:[[Int]]){
            if start == -1 {return}
            sum += tree[start][2]
            preorder(tree[start][0],tree)
            preorder(tree[start][1],tree)
        }
    
    
    
        for (i,link) in links.enumerated() {
            for l in link {
                if l != -1{
                    lines.append([i,l])
                }
            }
        }
    
        comb(lines,[],0,k - 1)
    
        for (i,link) in links.enumerated() {
            links[i] = link + [num[i]] 
        }
    
        findRoot(links)
        print("root = \(root)")
    
        for lineComb in lineCombs{
            var linksTemp = links
            var start:[Int] = []

            for lc in lineComb{
                 let deletedIndex = linksTemp[lc[0]].firstIndex(of:lc[1])
                linksTemp[lc[0]][deletedIndex!] = -1
                start.append(lc[1])
            }
        
            preorder(root,linksTemp)
            if max < sum {max = sum}
            sum = 0
            for s in start{
                preorder(s,linksTemp)
                if max < sum {max = sum}
                sum = 0
            }
            maxArray.append(max)
            max = 0
        }
    
    
        return maxArray.min()!
    }
    ```
